QUESTION_BEGIN
面向对象的特征有哪些方面
ANSWER_BEGIN
1.抽象：
抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。
抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，
一是过程抽象，二是数据抽象。
2.继承：
继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。
对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称
为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承
方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。
3.封装：
封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本
概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访
问其他对象。
4. 多态性：
多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态
性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。
END
QUESTION_BEGIN
String是最基本的数据类型吗?
ANSWER_BEGIN
基本数据类型包括byte、int、char、long、float、double、boolean和short。
javang.String类是final类型的，因此不可以继承这个类、不能修改这个类。为了提高效率节省空间
，我们应该用StringBuffer类
END
QUESTION_BEGIN
int 和 Integer 有什么区别
ANSWER_BEGIN
Java 提供两种不同的类型：引用类型和原始类型（或内置类型）。Int是java的原始数据类型，
Integer是java为int提供的封装类。Java为每个原始类型提供了封装类。
原始类型封装类
booleanBoolean
charCharacter
byteByte
shortShort
intInteger
longLong
floatFloat
doubleDouble
引用类型和原始类型的行为完全不同，并且它们具有不同的语义。引用类型和原始类型具有不
同的特征和用法，它们包括：大小和速度问题，这种类型以哪种类型的数据结构存储，当引用
类型和原始类型用作某个类的实例数据时所指定的缺省值。对象引用实例变量的缺省值为 null，
而原始类型实例变量的缺省值与它们的类型有关。
END
QUESTION_BEGIN
String 和StringBuffer的区别
ANSWER_BEGIN
JAVA平台提供了两个类：String和StringBuffer，它们可以储存和操作字符串，即包含多个字符
的字符数据。这个String类提供了数值不可改变的字符串。而这个StringBuffer类提供的字符串
进行修改。当你知道字符数据要改变的时候你就可以使用StringBuffer。典型地，你可以使用
StringBuffers来动态构造字符数据。
END
QUESTION_BEGIN
运行时异常与一般异常有何异同？
ANSWER_BEGIN
异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的
异常，是一种常见运行错误。java编译器要求方法必须声明抛出可能发生的非运行时异常，但是并
不要求必须声明抛出未被捕获的运行时异常。
END
QUESTION_BEGIN
说出Servlet的生命周期，并说出Servlet和CGI的区别。
ANSWER_BEGIN
Servlet被服务器实例化后，容器运行其init方法，请求到达时运行其service方法，service方法
自动派遣运行与请求对应的doXXX方法（doGet，doPost）等，当服务器决定将实例销毁的时候调用
其destroy方法。与cgi的区别在于servlet处于服务器进程中，它通过多线程方式运行其service方法，
一个实例可以服务于多个请求，并且其实例一般不会销毁，而CGI对每个请求都产生新的进程，
服务完成后就销毁，所以效率上低于servlet。
END
QUESTION_BEGIN
说出ArrayList,Vector, LinkedList的存储性能和特性
ANSWER_BEGIN
ArrayList和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，
它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入
数据慢，Vector由于使用了synchronized方法（线程安全），通常性能上较ArrayList差，而LinkedList
使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前
后项即可，所以插入速度较快。
END
QUESTION_BEGIN
面向对象的特征有哪些方面
ANSWER_BEGIN
1.抽象：
抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。
抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，
一是过程抽象，二是数据抽象。
2.继承：
继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。
对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称
为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承
方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。
3.封装：
封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本
概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访
问其他对象。
4. 多态性：
多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态
性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。
END
QUESTION_BEGIN
String是最基本的数据类型吗?
ANSWER_BEGIN
基本数据类型包括byte、int、char、long、float、double、boolean和short。
javang.String类是final类型的，因此不可以继承这个类、不能修改这个类。为了提高效率节省空间
，我们应该用StringBuffer类
END
QUESTION_BEGIN
int 和 Integer 有什么区别
ANSWER_BEGIN
Java 提供两种不同的类型：引用类型和原始类型（或内置类型）。Int是java的原始数据类型，
Integer是java为int提供的封装类。Java为每个原始类型提供了封装类。
原始类型封装类
booleanBoolean
charCharacter
byteByte
shortShort
intInteger
longLong
floatFloat
doubleDouble
引用类型和原始类型的行为完全不同，并且它们具有不同的语义。引用类型和原始类型具有不
同的特征和用法，它们包括：大小和速度问题，这种类型以哪种类型的数据结构存储，当引用
类型和原始类型用作某个类的实例数据时所指定的缺省值。对象引用实例变量的缺省值为 null，
而原始类型实例变量的缺省值与它们的类型有关。
END
QUESTION_BEGIN
String 和StringBuffer的区别
ANSWER_BEGIN
JAVA平台提供了两个类：String和StringBuffer，它们可以储存和操作字符串，即包含多个字符
的字符数据。这个String类提供了数值不可改变的字符串。而这个StringBuffer类提供的字符串
进行修改。当你知道字符数据要改变的时候你就可以使用StringBuffer。典型地，你可以使用
StringBuffers来动态构造字符数据。
END
QUESTION_BEGIN
运行时异常与一般异常有何异同？
ANSWER_BEGIN
异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的
异常，是一种常见运行错误。java编译器要求方法必须声明抛出可能发生的非运行时异常，但是并
不要求必须声明抛出未被捕获的运行时异常。
END
QUESTION_BEGIN
说出Servlet的生命周期，并说出Servlet和CGI的区别。
ANSWER_BEGIN
Servlet被服务器实例化后，容器运行其init方法，请求到达时运行其service方法，service方法
自动派遣运行与请求对应的doXXX方法（doGet，doPost）等，当服务器决定将实例销毁的时候调用
其destroy方法。与cgi的区别在于servlet处于服务器进程中，它通过多线程方式运行其service方法，
一个实例可以服务于多个请求，并且其实例一般不会销毁，而CGI对每个请求都产生新的进程，
服务完成后就销毁，所以效率上低于servlet。
END
QUESTION_BEGIN
说出ArrayList,Vector, LinkedList的存储性能和特性
ANSWER_BEGIN
ArrayList和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，
它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入
数据慢，Vector由于使用了synchronized方法（线程安全），通常性能上较ArrayList差，而LinkedList
使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前
后项即可，所以插入速度较快。
END
QUESTION_BEGIN
面向对象的特征有哪些方面
ANSWER_BEGIN
1.抽象：
抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。
抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，
一是过程抽象，二是数据抽象。
2.继承：
继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。
对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称
为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承
方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。
3.封装：
封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本
概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访
问其他对象。
4. 多态性：
多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态
性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。
END
QUESTION_BEGIN
String是最基本的数据类型吗?
ANSWER_BEGIN
基本数据类型包括byte、int、char、long、float、double、boolean和short。
javang.String类是final类型的，因此不可以继承这个类、不能修改这个类。为了提高效率节省空间
，我们应该用StringBuffer类
END
QUESTION_BEGIN
int 和 Integer 有什么区别
ANSWER_BEGIN
Java 提供两种不同的类型：引用类型和原始类型（或内置类型）。Int是java的原始数据类型，
Integer是java为int提供的封装类。Java为每个原始类型提供了封装类。
原始类型封装类
booleanBoolean
charCharacter
byteByte
shortShort
intInteger
longLong
floatFloat
doubleDouble
引用类型和原始类型的行为完全不同，并且它们具有不同的语义。引用类型和原始类型具有不
同的特征和用法，它们包括：大小和速度问题，这种类型以哪种类型的数据结构存储，当引用
类型和原始类型用作某个类的实例数据时所指定的缺省值。对象引用实例变量的缺省值为 null，
而原始类型实例变量的缺省值与它们的类型有关。
END
QUESTION_BEGIN
String 和StringBuffer的区别
ANSWER_BEGIN
JAVA平台提供了两个类：String和StringBuffer，它们可以储存和操作字符串，即包含多个字符
的字符数据。这个String类提供了数值不可改变的字符串。而这个StringBuffer类提供的字符串
进行修改。当你知道字符数据要改变的时候你就可以使用StringBuffer。典型地，你可以使用
StringBuffers来动态构造字符数据。
END
QUESTION_BEGIN
运行时异常与一般异常有何异同？
ANSWER_BEGIN
异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的
异常，是一种常见运行错误。java编译器要求方法必须声明抛出可能发生的非运行时异常，但是并
不要求必须声明抛出未被捕获的运行时异常。
END
QUESTION_BEGIN
说出Servlet的生命周期，并说出Servlet和CGI的区别。
ANSWER_BEGIN
Servlet被服务器实例化后，容器运行其init方法，请求到达时运行其service方法，service方法
自动派遣运行与请求对应的doXXX方法（doGet，doPost）等，当服务器决定将实例销毁的时候调用
其destroy方法。与cgi的区别在于servlet处于服务器进程中，它通过多线程方式运行其service方法，
一个实例可以服务于多个请求，并且其实例一般不会销毁，而CGI对每个请求都产生新的进程，
服务完成后就销毁，所以效率上低于servlet。
END
QUESTION_BEGIN
说出ArrayList,Vector, LinkedList的存储性能和特性
ANSWER_BEGIN
ArrayList和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，
它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入
数据慢，Vector由于使用了synchronized方法（线程安全），通常性能上较ArrayList差，而LinkedList
使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前
后项即可，所以插入速度较快。
END
QUESTION_BEGIN
面向对象的特征有哪些方面
ANSWER_BEGIN
1.抽象：
抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。
抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，
一是过程抽象，二是数据抽象。
2.继承：
继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。
对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称
为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承
方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。
3.封装：
封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本
概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访
问其他对象。
4. 多态性：
多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态
性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。
END
QUESTION_BEGIN
String是最基本的数据类型吗?
ANSWER_BEGIN
基本数据类型包括byte、int、char、long、float、double、boolean和short。
javang.String类是final类型的，因此不可以继承这个类、不能修改这个类。为了提高效率节省空间
，我们应该用StringBuffer类
END
QUESTION_BEGIN
int 和 Integer 有什么区别
ANSWER_BEGIN
Java 提供两种不同的类型：引用类型和原始类型（或内置类型）。Int是java的原始数据类型，
Integer是java为int提供的封装类。Java为每个原始类型提供了封装类。
原始类型封装类
booleanBoolean
charCharacter
byteByte
shortShort
intInteger
longLong
floatFloat
doubleDouble
引用类型和原始类型的行为完全不同，并且它们具有不同的语义。引用类型和原始类型具有不
同的特征和用法，它们包括：大小和速度问题，这种类型以哪种类型的数据结构存储，当引用
类型和原始类型用作某个类的实例数据时所指定的缺省值。对象引用实例变量的缺省值为 null，
而原始类型实例变量的缺省值与它们的类型有关。
END
QUESTION_BEGIN
String 和StringBuffer的区别
ANSWER_BEGIN
JAVA平台提供了两个类：String和StringBuffer，它们可以储存和操作字符串，即包含多个字符
的字符数据。这个String类提供了数值不可改变的字符串。而这个StringBuffer类提供的字符串
进行修改。当你知道字符数据要改变的时候你就可以使用StringBuffer。典型地，你可以使用
StringBuffers来动态构造字符数据。
END
QUESTION_BEGIN
运行时异常与一般异常有何异同？
ANSWER_BEGIN
异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的
异常，是一种常见运行错误。java编译器要求方法必须声明抛出可能发生的非运行时异常，但是并
不要求必须声明抛出未被捕获的运行时异常。
END
QUESTION_BEGIN
说出Servlet的生命周期，并说出Servlet和CGI的区别。
ANSWER_BEGIN
Servlet被服务器实例化后，容器运行其init方法，请求到达时运行其service方法，service方法
自动派遣运行与请求对应的doXXX方法（doGet，doPost）等，当服务器决定将实例销毁的时候调用
其destroy方法。与cgi的区别在于servlet处于服务器进程中，它通过多线程方式运行其service方法，
一个实例可以服务于多个请求，并且其实例一般不会销毁，而CGI对每个请求都产生新的进程，
服务完成后就销毁，所以效率上低于servlet。
END
QUESTION_BEGIN
说出ArrayList,Vector, LinkedList的存储性能和特性
ANSWER_BEGIN
ArrayList和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，
它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入
数据慢，Vector由于使用了synchronized方法（线程安全），通常性能上较ArrayList差，而LinkedList
使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前
后项即可，所以插入速度较快。
END
QUESTION_BEGIN
面向对象的特征有哪些方面
ANSWER_BEGIN
1.抽象：
抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。
抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，
一是过程抽象，二是数据抽象。
2.继承：
继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。
对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称
为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承
方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。
3.封装：
封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本
概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访
问其他对象。
4. 多态性：
多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态
性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。
END
QUESTION_BEGIN
String是最基本的数据类型吗?
ANSWER_BEGIN
基本数据类型包括byte、int、char、long、float、double、boolean和short。
javang.String类是final类型的，因此不可以继承这个类、不能修改这个类。为了提高效率节省空间
，我们应该用StringBuffer类
END
QUESTION_BEGIN
int 和 Integer 有什么区别
ANSWER_BEGIN
Java 提供两种不同的类型：引用类型和原始类型（或内置类型）。Int是java的原始数据类型，
Integer是java为int提供的封装类。Java为每个原始类型提供了封装类。
原始类型封装类
booleanBoolean
charCharacter
byteByte
shortShort
intInteger
longLong
floatFloat
doubleDouble
引用类型和原始类型的行为完全不同，并且它们具有不同的语义。引用类型和原始类型具有不
同的特征和用法，它们包括：大小和速度问题，这种类型以哪种类型的数据结构存储，当引用
类型和原始类型用作某个类的实例数据时所指定的缺省值。对象引用实例变量的缺省值为 null，
而原始类型实例变量的缺省值与它们的类型有关。
END
QUESTION_BEGIN
String 和StringBuffer的区别
ANSWER_BEGIN
JAVA平台提供了两个类：String和StringBuffer，它们可以储存和操作字符串，即包含多个字符
的字符数据。这个String类提供了数值不可改变的字符串。而这个StringBuffer类提供的字符串
进行修改。当你知道字符数据要改变的时候你就可以使用StringBuffer。典型地，你可以使用
StringBuffers来动态构造字符数据。
END
QUESTION_BEGIN
运行时异常与一般异常有何异同？
ANSWER_BEGIN
异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的
异常，是一种常见运行错误。java编译器要求方法必须声明抛出可能发生的非运行时异常，但是并
不要求必须声明抛出未被捕获的运行时异常。
END
QUESTION_BEGIN
说出Servlet的生命周期，并说出Servlet和CGI的区别。
ANSWER_BEGIN
Servlet被服务器实例化后，容器运行其init方法，请求到达时运行其service方法，service方法
自动派遣运行与请求对应的doXXX方法（doGet，doPost）等，当服务器决定将实例销毁的时候调用
其destroy方法。与cgi的区别在于servlet处于服务器进程中，它通过多线程方式运行其service方法，
一个实例可以服务于多个请求，并且其实例一般不会销毁，而CGI对每个请求都产生新的进程，
服务完成后就销毁，所以效率上低于servlet。
END
QUESTION_BEGIN
说出ArrayList,Vector, LinkedList的存储性能和特性
ANSWER_BEGIN
ArrayList和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，
它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入
数据慢，Vector由于使用了synchronized方法（线程安全），通常性能上较ArrayList差，而LinkedList
使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前
后项即可，所以插入速度较快。
END
QUESTION_BEGIN
面向对象的特征有哪些方面
ANSWER_BEGIN
1.抽象：
抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。
抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，
一是过程抽象，二是数据抽象。
2.继承：
继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。
对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称
为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承
方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。
3.封装：
封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本
概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访
问其他对象。
4. 多态性：
多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态
性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。
END
QUESTION_BEGIN
String是最基本的数据类型吗?
ANSWER_BEGIN
基本数据类型包括byte、int、char、long、float、double、boolean和short。
javang.String类是final类型的，因此不可以继承这个类、不能修改这个类。为了提高效率节省空间
，我们应该用StringBuffer类
END
QUESTION_BEGIN
int 和 Integer 有什么区别
ANSWER_BEGIN
Java 提供两种不同的类型：引用类型和原始类型（或内置类型）。Int是java的原始数据类型，
Integer是java为int提供的封装类。Java为每个原始类型提供了封装类。
原始类型封装类
booleanBoolean
charCharacter
byteByte
shortShort
intInteger
longLong
floatFloat
doubleDouble
引用类型和原始类型的行为完全不同，并且它们具有不同的语义。引用类型和原始类型具有不
同的特征和用法，它们包括：大小和速度问题，这种类型以哪种类型的数据结构存储，当引用
类型和原始类型用作某个类的实例数据时所指定的缺省值。对象引用实例变量的缺省值为 null，
而原始类型实例变量的缺省值与它们的类型有关。
END
QUESTION_BEGIN
String 和StringBuffer的区别
ANSWER_BEGIN
JAVA平台提供了两个类：String和StringBuffer，它们可以储存和操作字符串，即包含多个字符
的字符数据。这个String类提供了数值不可改变的字符串。而这个StringBuffer类提供的字符串
进行修改。当你知道字符数据要改变的时候你就可以使用StringBuffer。典型地，你可以使用
StringBuffers来动态构造字符数据。
END
QUESTION_BEGIN
运行时异常与一般异常有何异同？
ANSWER_BEGIN
异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的
异常，是一种常见运行错误。java编译器要求方法必须声明抛出可能发生的非运行时异常，但是并
不要求必须声明抛出未被捕获的运行时异常。
END
QUESTION_BEGIN
说出Servlet的生命周期，并说出Servlet和CGI的区别。
ANSWER_BEGIN
Servlet被服务器实例化后，容器运行其init方法，请求到达时运行其service方法，service方法
自动派遣运行与请求对应的doXXX方法（doGet，doPost）等，当服务器决定将实例销毁的时候调用
其destroy方法。与cgi的区别在于servlet处于服务器进程中，它通过多线程方式运行其service方法，
一个实例可以服务于多个请求，并且其实例一般不会销毁，而CGI对每个请求都产生新的进程，
服务完成后就销毁，所以效率上低于servlet。
END
QUESTION_BEGIN
说出ArrayList,Vector, LinkedList的存储性能和特性
ANSWER_BEGIN
ArrayList和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，
它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入
数据慢，Vector由于使用了synchronized方法（线程安全），通常性能上较ArrayList差，而LinkedList
使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前
后项即可，所以插入速度较快。
END
QUESTION_BEGIN
面向对象的特征有哪些方面
ANSWER_BEGIN
1.抽象：
抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。
抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，
一是过程抽象，二是数据抽象。
2.继承：
继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。
对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称
为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承
方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。
3.封装：
封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本
概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访
问其他对象。
4. 多态性：
多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态
性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。
END
QUESTION_BEGIN
String是最基本的数据类型吗?
ANSWER_BEGIN
基本数据类型包括byte、int、char、long、float、double、boolean和short。
javang.String类是final类型的，因此不可以继承这个类、不能修改这个类。为了提高效率节省空间
，我们应该用StringBuffer类
END
QUESTION_BEGIN
int 和 Integer 有什么区别
ANSWER_BEGIN
Java 提供两种不同的类型：引用类型和原始类型（或内置类型）。Int是java的原始数据类型，
Integer是java为int提供的封装类。Java为每个原始类型提供了封装类。
原始类型封装类
booleanBoolean
charCharacter
byteByte
shortShort
intInteger
longLong
floatFloat
doubleDouble
引用类型和原始类型的行为完全不同，并且它们具有不同的语义。引用类型和原始类型具有不
同的特征和用法，它们包括：大小和速度问题，这种类型以哪种类型的数据结构存储，当引用
类型和原始类型用作某个类的实例数据时所指定的缺省值。对象引用实例变量的缺省值为 null，
而原始类型实例变量的缺省值与它们的类型有关。
END
QUESTION_BEGIN
String 和StringBuffer的区别
ANSWER_BEGIN
JAVA平台提供了两个类：String和StringBuffer，它们可以储存和操作字符串，即包含多个字符
的字符数据。这个String类提供了数值不可改变的字符串。而这个StringBuffer类提供的字符串
进行修改。当你知道字符数据要改变的时候你就可以使用StringBuffer。典型地，你可以使用
StringBuffers来动态构造字符数据。
END
QUESTION_BEGIN
运行时异常与一般异常有何异同？
ANSWER_BEGIN
异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的
异常，是一种常见运行错误。java编译器要求方法必须声明抛出可能发生的非运行时异常，但是并
不要求必须声明抛出未被捕获的运行时异常。
END
QUESTION_BEGIN
说出Servlet的生命周期，并说出Servlet和CGI的区别。
ANSWER_BEGIN
Servlet被服务器实例化后，容器运行其init方法，请求到达时运行其service方法，service方法
自动派遣运行与请求对应的doXXX方法（doGet，doPost）等，当服务器决定将实例销毁的时候调用
其destroy方法。与cgi的区别在于servlet处于服务器进程中，它通过多线程方式运行其service方法，
一个实例可以服务于多个请求，并且其实例一般不会销毁，而CGI对每个请求都产生新的进程，
服务完成后就销毁，所以效率上低于servlet。
END
QUESTION_BEGIN
说出ArrayList,Vector, LinkedList的存储性能和特性
ANSWER_BEGIN
ArrayList和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，
它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入
数据慢，Vector由于使用了synchronized方法（线程安全），通常性能上较ArrayList差，而LinkedList
使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前
后项即可，所以插入速度较快。
END
QUESTION_BEGIN
面向对象的特征有哪些方面
ANSWER_BEGIN
1.抽象：
抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。
抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，
一是过程抽象，二是数据抽象。
2.继承：
继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。
对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称
为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承
方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。
3.封装：
封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本
概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访
问其他对象。
4. 多态性：
多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态
性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。
END
QUESTION_BEGIN
String是最基本的数据类型吗?
ANSWER_BEGIN
基本数据类型包括byte、int、char、long、float、double、boolean和short。
javang.String类是final类型的，因此不可以继承这个类、不能修改这个类。为了提高效率节省空间
，我们应该用StringBuffer类
END
QUESTION_BEGIN
int 和 Integer 有什么区别
ANSWER_BEGIN
Java 提供两种不同的类型：引用类型和原始类型（或内置类型）。Int是java的原始数据类型，
Integer是java为int提供的封装类。Java为每个原始类型提供了封装类。
原始类型封装类
booleanBoolean
charCharacter
byteByte
shortShort
intInteger
longLong
floatFloat
doubleDouble
引用类型和原始类型的行为完全不同，并且它们具有不同的语义。引用类型和原始类型具有不
同的特征和用法，它们包括：大小和速度问题，这种类型以哪种类型的数据结构存储，当引用
类型和原始类型用作某个类的实例数据时所指定的缺省值。对象引用实例变量的缺省值为 null，
而原始类型实例变量的缺省值与它们的类型有关。
END
QUESTION_BEGIN
String 和StringBuffer的区别
ANSWER_BEGIN
JAVA平台提供了两个类：String和StringBuffer，它们可以储存和操作字符串，即包含多个字符
的字符数据。这个String类提供了数值不可改变的字符串。而这个StringBuffer类提供的字符串
进行修改。当你知道字符数据要改变的时候你就可以使用StringBuffer。典型地，你可以使用
StringBuffers来动态构造字符数据。
END
QUESTION_BEGIN
运行时异常与一般异常有何异同？
ANSWER_BEGIN
异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的
异常，是一种常见运行错误。java编译器要求方法必须声明抛出可能发生的非运行时异常，但是并
不要求必须声明抛出未被捕获的运行时异常。
END
QUESTION_BEGIN
说出Servlet的生命周期，并说出Servlet和CGI的区别。
ANSWER_BEGIN
Servlet被服务器实例化后，容器运行其init方法，请求到达时运行其service方法，service方法
自动派遣运行与请求对应的doXXX方法（doGet，doPost）等，当服务器决定将实例销毁的时候调用
其destroy方法。与cgi的区别在于servlet处于服务器进程中，它通过多线程方式运行其service方法，
一个实例可以服务于多个请求，并且其实例一般不会销毁，而CGI对每个请求都产生新的进程，
服务完成后就销毁，所以效率上低于servlet。
END
QUESTION_BEGIN
说出ArrayList,Vector, LinkedList的存储性能和特性
ANSWER_BEGIN
ArrayList和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，
它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入
数据慢，Vector由于使用了synchronized方法（线程安全），通常性能上较ArrayList差，而LinkedList
使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前
后项即可，所以插入速度较快。
END
QUESTION_BEGIN
面向对象的特征有哪些方面
ANSWER_BEGIN
1.抽象：
抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。
抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，
一是过程抽象，二是数据抽象。
2.继承：
继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。
对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称
为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承
方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。
3.封装：
封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本
概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访
问其他对象。
4. 多态性：
多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态
性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。
END
QUESTION_BEGIN
String是最基本的数据类型吗?
ANSWER_BEGIN
基本数据类型包括byte、int、char、long、float、double、boolean和short。
javang.String类是final类型的，因此不可以继承这个类、不能修改这个类。为了提高效率节省空间
，我们应该用StringBuffer类
END
QUESTION_BEGIN
int 和 Integer 有什么区别
ANSWER_BEGIN
Java 提供两种不同的类型：引用类型和原始类型（或内置类型）。Int是java的原始数据类型，
Integer是java为int提供的封装类。Java为每个原始类型提供了封装类。
原始类型封装类
booleanBoolean
charCharacter
byteByte
shortShort
intInteger
longLong
floatFloat
doubleDouble
引用类型和原始类型的行为完全不同，并且它们具有不同的语义。引用类型和原始类型具有不
同的特征和用法，它们包括：大小和速度问题，这种类型以哪种类型的数据结构存储，当引用
类型和原始类型用作某个类的实例数据时所指定的缺省值。对象引用实例变量的缺省值为 null，
而原始类型实例变量的缺省值与它们的类型有关。
END
QUESTION_BEGIN
String 和StringBuffer的区别
ANSWER_BEGIN
JAVA平台提供了两个类：String和StringBuffer，它们可以储存和操作字符串，即包含多个字符
的字符数据。这个String类提供了数值不可改变的字符串。而这个StringBuffer类提供的字符串
进行修改。当你知道字符数据要改变的时候你就可以使用StringBuffer。典型地，你可以使用
StringBuffers来动态构造字符数据。
END
QUESTION_BEGIN
运行时异常与一般异常有何异同？
ANSWER_BEGIN
异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的
异常，是一种常见运行错误。java编译器要求方法必须声明抛出可能发生的非运行时异常，但是并
不要求必须声明抛出未被捕获的运行时异常。
END
QUESTION_BEGIN
说出Servlet的生命周期，并说出Servlet和CGI的区别。
ANSWER_BEGIN
Servlet被服务器实例化后，容器运行其init方法，请求到达时运行其service方法，service方法
自动派遣运行与请求对应的doXXX方法（doGet，doPost）等，当服务器决定将实例销毁的时候调用
其destroy方法。与cgi的区别在于servlet处于服务器进程中，它通过多线程方式运行其service方法，
一个实例可以服务于多个请求，并且其实例一般不会销毁，而CGI对每个请求都产生新的进程，
服务完成后就销毁，所以效率上低于servlet。
END
QUESTION_BEGIN
说出ArrayList,Vector, LinkedList的存储性能和特性
ANSWER_BEGIN
ArrayList和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，
它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入
数据慢，Vector由于使用了synchronized方法（线程安全），通常性能上较ArrayList差，而LinkedList
使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前
后项即可，所以插入速度较快。
END
QUESTION_BEGIN
面向对象的特征有哪些方面
ANSWER_BEGIN
1.抽象：
抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。
抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，
一是过程抽象，二是数据抽象。
2.继承：
继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。
对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称
为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承
方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。
3.封装：
封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本
概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访
问其他对象。
4. 多态性：
多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态
性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。
END
QUESTION_BEGIN
String是最基本的数据类型吗?
ANSWER_BEGIN
基本数据类型包括byte、int、char、long、float、double、boolean和short。
javang.String类是final类型的，因此不可以继承这个类、不能修改这个类。为了提高效率节省空间
，我们应该用StringBuffer类
END
QUESTION_BEGIN
int 和 Integer 有什么区别
ANSWER_BEGIN
Java 提供两种不同的类型：引用类型和原始类型（或内置类型）。Int是java的原始数据类型，
Integer是java为int提供的封装类。Java为每个原始类型提供了封装类。
原始类型封装类
booleanBoolean
charCharacter
byteByte
shortShort
intInteger
longLong
floatFloat
doubleDouble
引用类型和原始类型的行为完全不同，并且它们具有不同的语义。引用类型和原始类型具有不
同的特征和用法，它们包括：大小和速度问题，这种类型以哪种类型的数据结构存储，当引用
类型和原始类型用作某个类的实例数据时所指定的缺省值。对象引用实例变量的缺省值为 null，
而原始类型实例变量的缺省值与它们的类型有关。
END
QUESTION_BEGIN
String 和StringBuffer的区别
ANSWER_BEGIN
JAVA平台提供了两个类：String和StringBuffer，它们可以储存和操作字符串，即包含多个字符
的字符数据。这个String类提供了数值不可改变的字符串。而这个StringBuffer类提供的字符串
进行修改。当你知道字符数据要改变的时候你就可以使用StringBuffer。典型地，你可以使用
StringBuffers来动态构造字符数据。
END
QUESTION_BEGIN
运行时异常与一般异常有何异同？
ANSWER_BEGIN
异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的
异常，是一种常见运行错误。java编译器要求方法必须声明抛出可能发生的非运行时异常，但是并
不要求必须声明抛出未被捕获的运行时异常。
END
QUESTION_BEGIN
说出Servlet的生命周期，并说出Servlet和CGI的区别。
ANSWER_BEGIN
Servlet被服务器实例化后，容器运行其init方法，请求到达时运行其service方法，service方法
自动派遣运行与请求对应的doXXX方法（doGet，doPost）等，当服务器决定将实例销毁的时候调用
其destroy方法。与cgi的区别在于servlet处于服务器进程中，它通过多线程方式运行其service方法，
一个实例可以服务于多个请求，并且其实例一般不会销毁，而CGI对每个请求都产生新的进程，
服务完成后就销毁，所以效率上低于servlet。
END
QUESTION_BEGIN
说出ArrayList,Vector, LinkedList的存储性能和特性
ANSWER_BEGIN
ArrayList和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，
它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入
数据慢，Vector由于使用了synchronized方法（线程安全），通常性能上较ArrayList差，而LinkedList
使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前
后项即可，所以插入速度较快。
END

